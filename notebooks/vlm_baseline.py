# -*- coding: utf-8 -*-
"""vlm_baseline.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GC_PuvfG_cGOLxW0-oZrMTGixkV3Wt_2
"""

!pip -q install -U google-genai pydantic pandas pillow
import os, getpass
from google import genai
from google.genai import types
from google.colab import drive
from pydantic import BaseModel, Field
from typing import List, Literal
import mimetypes, json, time
import os
import pandas as pd
from google.colab import files

os.environ["GEMINI_API_KEY"] = getpass.getpass("Gemini API key: ")

client = genai.Client(api_key=os.environ["GEMINI_API_KEY"])

drive.mount("/content/drive")

IMG_DIR = "drive/MyDrive/COS429FinalProject/TrainTestValSplitData/test/images"



class FoodItem(BaseModel):
    name: str
    estimated_calories: int = Field(ge=0)

class CalorieEstimate(BaseModel):
    estimated_calories: int = Field(ge=0)
    calorie_range: List[int] = Field(min_length=2, max_length=2)
    foods: List[FoodItem]
    assumptions: List[str]
    confidence: Literal["low", "medium", "high"]

MODEL = "gemini-2.5-flash"
PROMPT = """
Estimate the TOTAL calories for the entire serving shown in the image.

Guidelines:
- Identify each visible food item and estimate calories for each and remember calories is per item and not portion size.
- Sum to estimated_calories.
- Provide calorie_range [low, high] capturing uncertainty (portion size, oils, sauces).
- If it's not food or you can't tell, return low confidence and conservative estimates. The only possible categories for the foods are as follows:
milano cookie
oreo
popcorn
pretzel crisp
roasted chestnut
sour patch kid
swedish fish

The calories are {
    "milano cookie": 65,      # per cookie
    "oreo": 70,               # per cookie
    "popcorn": 2.25,          # per one popcorn
    "pretzel crisp": 10,      # per crisp
    "roasted chestnut": 20,   # per chestnut
    "sour patch kid": 9,      # per candy
    "swedish fish": 22        # per candy
}
"""

def estimate_calories_one(image_path: str, max_retries: int = 3) -> CalorieEstimate | None:
    mime, _ = mimetypes.guess_type(image_path)
    mime = mime or "image/jpeg"

    with open(image_path, "rb") as f:
        image_bytes = f.read()

    for attempt in range(max_retries):
        try:
            resp = client.models.generate_content(
                model=MODEL,
                contents=[
                    types.Part.from_bytes(data=image_bytes, mime_type=mime),
                    PROMPT,
                ],
                config=types.GenerateContentConfig(
                    response_mime_type="application/json",
                    response_schema=CalorieEstimate,
                    temperature=0.2,
                ),
            )

            # With structured output, resp.parsed is typically available:
            if getattr(resp, "parsed", None) is not None:
                return resp.parsed

            # Fallback: parse JSON text if needed
            return CalorieEstimate.model_validate_json(resp.text)

        except Exception as e:
            if attempt == max_retries - 1:
                print(f"[FAIL] {image_path}: {e}")
                return None
            time.sleep(1.5 * (attempt + 1))

import os, json
import pandas as pd

rows = []
os.makedirs("vlm_outputs", exist_ok=True)

for fn in sorted(os.listdir(IMG_DIR)):
    if not fn.lower().endswith((".jpg", ".jpeg")):
        continue

    path = os.path.join(IMG_DIR, fn)
    if not os.path.isfile(path):
        continue

    est = estimate_calories_one(path)
    if est is None:
        rows.append({"filename": fn, "error": True})
        continue

    rows.append({
        "filename": fn,
        "estimated_calories": est.estimated_calories,
        "range_low": est.calorie_range[0],
        "range_high": est.calorie_range[1],
        "confidence": est.confidence,
        "foods": json.dumps([f.model_dump() for f in est.foods], ensure_ascii=False),
        "assumptions": json.dumps(est.assumptions, ensure_ascii=False),
        "error": False,
    })

    # optional: checkpoint every 10 images
    if len(rows) % 10 == 0:
        pd.DataFrame(rows).to_csv("vlm_outputs/calorie_estimates_partial.csv", index=False)
        print(f"Processed {len(rows)} images...")

df = pd.DataFrame(rows)
df.to_csv("vlm_outputs/calorie_estimates.csv", index=False)
df.head()

files.download("vlm_outputs/calorie_estimates.csv")

ls